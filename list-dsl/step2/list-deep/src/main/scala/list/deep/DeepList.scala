/* Generated by Purgatory 2014-2016 */

package list.deep

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

import ch.epfl.data.sc.pardis.quasi.anf.{ BaseExt, BaseExtIR }
import ch.epfl.data.sc.pardis.quasi.TypeParameters.MaybeParamTag

trait ListOps extends Base with Tuple2Ops with SeqOps {  
  // Type representation
  val ListType = ListIRs.ListType
  type ListType[A] = ListIRs.ListType[A]
  implicit def typeList[A: TypeRep]: TypeRep[List[A]] = ListType(implicitly[TypeRep[A]])
  implicit class ListRep[A](self : Rep[List[A]])(implicit typeA : TypeRep[A]) {
     def map[B](f : Rep[(A => B)])(implicit typeB : TypeRep[B]) : Rep[List[B]] = listMap[A, B](self, f)(typeA, typeB)
     def filter(f : Rep[(A => Boolean)]) : Rep[List[A]] = listFilter[A](self, f)(typeA)
     def fold[B](init : Rep[B], f : Rep[((B,A) => B)])(implicit typeB : TypeRep[B]) : Rep[B] = listFold[A, B](self, init, f)(typeA, typeB)
     def size : Rep[Int] = listSize[A](self)(typeA)
     def +(that : Rep[A]) : Rep[List[A]] = list$plus[A](self, that)(typeA)
     def print() : Rep[Unit] = listPrint[A](self)(typeA)
     def data : Rep[Seq[A]] = list_Field_Data[A](self)(typeA)
  }
  object List {
     def apply[A](data : Rep[A]*)(implicit typeA : TypeRep[A], overload1 : Overloaded1) : Rep[List[A]] = listApplyObject1[A](data:_*)(typeA)
     def apply[A]()(implicit typeA : TypeRep[A], overload2 : Overloaded2) : Rep[List[A]] = listApplyObject2[A]()(typeA)
     def zip[A, B](as : Rep[List[A]], bs : Rep[List[B]])(implicit typeA : TypeRep[A], typeB : TypeRep[B]) : Rep[List[Tuple2[A, B]]] = listZipObject[A, B](as, bs)(typeA, typeB)
  }
  // constructors
   def __newList[A](data : Rep[Seq[A]])(implicit typeA : TypeRep[A]) : Rep[List[A]] = listNew[A](data)(typeA)
  // IR defs
  val ListNew = ListIRs.ListNew
  type ListNew[A] = ListIRs.ListNew[A]
  val ListMap = ListIRs.ListMap
  type ListMap[A, B] = ListIRs.ListMap[A, B]
  val ListFilter = ListIRs.ListFilter
  type ListFilter[A] = ListIRs.ListFilter[A]
  val ListFold = ListIRs.ListFold
  type ListFold[A, B] = ListIRs.ListFold[A, B]
  val ListSize = ListIRs.ListSize
  type ListSize[A] = ListIRs.ListSize[A]
  val List$plus = ListIRs.List$plus
  type List$plus[A] = ListIRs.List$plus[A]
  val ListPrint = ListIRs.ListPrint
  type ListPrint[A] = ListIRs.ListPrint[A]
  val List_Field_Data = ListIRs.List_Field_Data
  type List_Field_Data[A] = ListIRs.List_Field_Data[A]
  val ListApplyObject1 = ListIRs.ListApplyObject1
  type ListApplyObject1[A] = ListIRs.ListApplyObject1[A]
  val ListApplyObject2 = ListIRs.ListApplyObject2
  type ListApplyObject2[A] = ListIRs.ListApplyObject2[A]
  val ListZipObject = ListIRs.ListZipObject
  type ListZipObject[A, B] = ListIRs.ListZipObject[A, B]
  // method definitions
   def listNew[A](data : Rep[Seq[A]])(implicit typeA : TypeRep[A]) : Rep[List[A]] = ListNew[A](data)
   def listMap[A, B](self : Rep[List[A]], f : Rep[((A) => B)])(implicit typeA : TypeRep[A], typeB : TypeRep[B]) : Rep[List[B]] = ListMap[A, B](self, f)
   def listFilter[A](self : Rep[List[A]], f : Rep[((A) => Boolean)])(implicit typeA : TypeRep[A]) : Rep[List[A]] = ListFilter[A](self, f)
   def listFold[A, B](self : Rep[List[A]], init : Rep[B], f : Rep[((B,A) => B)])(implicit typeA : TypeRep[A], typeB : TypeRep[B]) : Rep[B] = ListFold[A, B](self, init, f)
   def listSize[A](self : Rep[List[A]])(implicit typeA : TypeRep[A]) : Rep[Int] = ListSize[A](self)
   def list$plus[A](self : Rep[List[A]], that : Rep[A])(implicit typeA : TypeRep[A]) : Rep[List[A]] = List$plus[A](self, that)
   def listPrint[A](self : Rep[List[A]])(implicit typeA : TypeRep[A]) : Rep[Unit] = ListPrint[A](self)
   def list_Field_Data[A](self : Rep[List[A]])(implicit typeA : TypeRep[A]) : Rep[Seq[A]] = List_Field_Data[A](self)
   def listApplyObject1[A](data : Rep[A]*)(implicit typeA : TypeRep[A]) : Rep[List[A]] = {
    val dataOutput = __liftSeq(data.toSeq)
    ListApplyObject1[A](dataOutput)
  }
   def listApplyObject2[A]()(implicit typeA : TypeRep[A]) : Rep[List[A]] = ListApplyObject2[A]()
   def listZipObject[A, B](as : Rep[List[A]], bs : Rep[List[B]])(implicit typeA : TypeRep[A], typeB : TypeRep[B]) : Rep[List[Tuple2[A, B]]] = ListZipObject[A, B](as, bs)
  type List[A] = list.shallow.List[A]
}
object ListIRs extends Base {
  import Tuple2IRs._
  import SeqIRs._
  // Type representation
  case class ListType[A](typeA: TypeRep[A]) extends TypeRep[List[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = ListType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"List[${typeA.name}]"
    val typeArguments = List(typeA)
  }
      implicit def typeList[A: TypeRep]: TypeRep[List[A]] = ListType(implicitly[TypeRep[A]])
  // case classes
  case class ListNew[A](data : Rep[Seq[A]])(implicit val typeA : TypeRep[A]) extends ConstructorDef[List[A]](List(typeA), "List", List(List(data))){
    override def curriedConstructor = (copy[A] _)
  }

  case class ListMap[A, B](self : Rep[List[A]], f : Rep[((A) => B)])(implicit val typeA : TypeRep[A], val typeB : TypeRep[B]) extends FunctionDef[List[B]](Some(self), "map", List(List(f))){
    override def curriedConstructor = (copy[A, B] _).curried
    override def isPure = true

    override def partiallyEvaluate(children: Any*): List[B] = {
      val self = children(0).asInstanceOf[List[A]]
      val f = children(1).asInstanceOf[((A) => B)]
      self.map[B](f)
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ListFilter[A](self : Rep[List[A]], f : Rep[((A) => Boolean)])(implicit val typeA : TypeRep[A]) extends FunctionDef[List[A]](Some(self), "filter", List(List(f))){
    override def curriedConstructor = (copy[A] _).curried
    override def isPure = true

    override def partiallyEvaluate(children: Any*): List[A] = {
      val self = children(0).asInstanceOf[List[A]]
      val f = children(1).asInstanceOf[((A) => Boolean)]
      self.filter(f)
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ListFold[A, B](self : Rep[List[A]], init : Rep[B], f : Rep[((B,A) => B)])(implicit val typeA : TypeRep[A], val typeB : TypeRep[B]) extends FunctionDef[B](Some(self), "fold", List(List(init,f))){
    override def curriedConstructor = (copy[A, B] _).curried
    override def isPure = true

    override def partiallyEvaluate(children: Any*): B = {
      val self = children(0).asInstanceOf[List[A]]
      val init = children(1).asInstanceOf[B]
      val f = children(2).asInstanceOf[((B,A) => B)]
      self.fold[B](init, f)
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ListSize[A](self : Rep[List[A]])(implicit val typeA : TypeRep[A]) extends FunctionDef[Int](Some(self), "size", List()){
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[List[A]]
      self.size
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class List$plus[A](self : Rep[List[A]], that : Rep[A])(implicit val typeA : TypeRep[A]) extends FunctionDef[List[A]](Some(self), "+", List(List(that))){
    override def curriedConstructor = (copy[A] _).curried
    override def isPure = true

    override def partiallyEvaluate(children: Any*): List[A] = {
      val self = children(0).asInstanceOf[List[A]]
      val that = children(1).asInstanceOf[A]
      self.$plus(that)
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ListPrint[A](self : Rep[List[A]])(implicit val typeA : TypeRep[A]) extends FunctionDef[Unit](Some(self), "print", List(List())){
    override def curriedConstructor = (copy[A] _)
  }

  case class List_Field_Data[A](self : Rep[List[A]])(implicit val typeA : TypeRep[A]) extends FieldDef[Seq[A]](self, "data"){
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Seq[A] = {
      val self = children(0).asInstanceOf[List[A]]
      self.data
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ListApplyObject1[A](dataOutput : Rep[Seq[A]])(implicit val typeA : TypeRep[A]) extends FunctionDef[List[A]](None, "List.apply", List(List(__varArg(dataOutput)))){
    override def curriedConstructor = (copy[A] _)
  }

  case class ListApplyObject2[A]()(implicit val typeA : TypeRep[A]) extends FunctionDef[List[A]](None, "List.apply", List(List()), List(typeA)){
    override def curriedConstructor = (x: Any) => copy[A]()
  }

  case class ListZipObject[A, B](as : Rep[List[A]], bs : Rep[List[B]])(implicit val typeA : TypeRep[A], val typeB : TypeRep[B]) extends FunctionDef[List[Tuple2[A, B]]](None, "List.zip", List(List(as,bs))){
    override def curriedConstructor = (copy[A, B] _).curried
  }

  type List[A] = list.shallow.List[A]
}
trait ListImplicits extends ListOps { 
  // Add implicit conversions here!
}
trait ListComponent extends ListOps with ListImplicits {  }

trait ListPartialEvaluation extends ListComponent with BasePartialEvaluation {  
  // Immutable field inlining 
  override def list_Field_Data[A](self : Rep[List[A]])(implicit typeA : TypeRep[A]) : Rep[Seq[A]] = self match {
    case Def(node: ListNew[_]) => node.data
    case _ => super.list_Field_Data[A](self)(typeA)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}


// QUASI GENERATED CODE:

object ListQuasiNodes extends BaseExtIR {
  import ListIRs._
  import Tuple2QuasiNodes._
  import SeqQuasiNodes._
  // case classes
  case class ListNewExt[A](data : Rep[Seq[A]])(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[ListNew[A], List[A]] {
    override def nodeUnapply(t: ListNew[A]): Option[Product] = (ListNew.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class ListMapExt[A, B](self : Rep[List[A]], f : Rep[((A) => B)])(implicit val paramA : MaybeParamTag[A], val paramB : MaybeParamTag[B]) extends FunctionDef[ListMap[A, B], List[B]] {
    override def nodeUnapply(t: ListMap[A, B]): Option[Product] = (ListMap.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      paramB.define(t.typeB)
      r }
  }
  case class ListFilterExt[A](self : Rep[List[A]], f : Rep[((A) => Boolean)])(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[ListFilter[A], List[A]] {
    override def nodeUnapply(t: ListFilter[A]): Option[Product] = (ListFilter.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class ListFoldExt[A, B](self : Rep[List[A]], init : Rep[B], f : Rep[((B,A) => B)])(implicit val paramA : MaybeParamTag[A], val paramB : MaybeParamTag[B]) extends FunctionDef[ListFold[A, B], B] {
    override def nodeUnapply(t: ListFold[A, B]): Option[Product] = (ListFold.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      paramB.define(t.typeB)
      r }
  }
  case class ListSizeExt[A](self : Rep[List[A]])(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[ListSize[A], Int] {
    override def nodeUnapply(t: ListSize[A]): Option[Product] = (ListSize.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class List$plusExt[A](self : Rep[List[A]], that : Rep[A])(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[List$plus[A], List[A]] {
    override def nodeUnapply(t: List$plus[A]): Option[Product] = (List$plus.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class ListPrintExt[A](self : Rep[List[A]])(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[ListPrint[A], Unit] {
    override def nodeUnapply(t: ListPrint[A]): Option[Product] = (ListPrint.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class List_Field_DataExt[A](self : Rep[List[A]])(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[List_Field_Data[A], Seq[A]] {
    override def nodeUnapply(t: List_Field_Data[A]): Option[Product] = (List_Field_Data.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class ListApplyObject1Ext[A](dataOutput : Rep[Seq[A]])(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[ListApplyObject1[A], List[A]] {
    override def nodeUnapply(t: ListApplyObject1[A]): Option[Product] = (ListApplyObject1.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class ListApplyObject2Ext[A]()(implicit val paramA : MaybeParamTag[A]) extends FunctionDef[ListApplyObject2[A], List[A]] {
    override def nodeUnapply(t: ListApplyObject2[A]): Option[Product] = (ListApplyObject2.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      r }
  }
  case class ListZipObjectExt[A, B](as : Rep[List[A]], bs : Rep[List[B]])(implicit val paramA : MaybeParamTag[A], val paramB : MaybeParamTag[B]) extends FunctionDef[ListZipObject[A, B], List[Tuple2[A, B]]] {
    override def nodeUnapply(t: ListZipObject[A, B]): Option[Product] = (ListZipObject.unapply(t): Option[Product]) map { r =>
      paramA.define(t.typeA)
      paramB.define(t.typeB)
      r }
  }
  type List[A] = list.shallow.List[A]
}

trait ListExtOps extends BaseExt with Tuple2ExtOps with SeqExtOps {
  
  import ListQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import Tuple2QuasiNodes._
  import SeqQuasiNodes._
  implicit class ListRep[A](self : Rep[List[A]])(implicit paramA : MaybeParamTag[A]) {
     def map[B](f : Rep[(A => B)])(implicit paramB : MaybeParamTag[B]) : Rep[List[B]] = listMap[A, B](self, f)(paramA, paramB)
     def filter(f : Rep[(A => Boolean)]) : Rep[List[A]] = listFilter[A](self, f)(paramA)
     def fold[B](init : Rep[B], f : Rep[((B,A) => B)])(implicit paramB : MaybeParamTag[B]) : Rep[B] = listFold[A, B](self, init, f)(paramA, paramB)
     def size : Rep[Int] = listSize[A](self)(paramA)
     def +(that : Rep[A]) : Rep[List[A]] = list$plus[A](self, that)(paramA)
     def print() : Rep[Unit] = listPrint[A](self)(paramA)
     def data : Rep[Seq[A]] = list_Field_Data[A](self)(paramA)
  }
  object List {
     def apply[A](data : Rep[A]*)(implicit overload1 : Overloaded1, paramA : MaybeParamTag[A]) : Rep[List[A]] = listApplyObject1[A](data:_*)(paramA)
     def apply[A]()(implicit overload2 : Overloaded2, paramA : MaybeParamTag[A]) : Rep[List[A]] = listApplyObject2[A]()(paramA)
     def zip[A, B](as : Rep[List[A]], bs : Rep[List[B]])(implicit paramA : MaybeParamTag[A], paramB : MaybeParamTag[B]) : Rep[List[Tuple2[A, B]]] = listZipObject[A, B](as, bs)(paramA, paramB)
  }
  // constructors
   def __newList[A](data : Rep[Seq[A]])(implicit paramA : MaybeParamTag[A]) : Rep[List[A]] = listNew[A](data)(paramA)
  
  // method definitions
   def listNew[A](data : Rep[Seq[A]])(implicit paramA : MaybeParamTag[A]) : Rep[List[A]] = ListNewExt[A](data)
   def listMap[A, B](self : Rep[List[A]], f : Rep[((A) => B)])(implicit paramA : MaybeParamTag[A], paramB : MaybeParamTag[B]) : Rep[List[B]] = ListMapExt[A, B](self, f)
   def listFilter[A](self : Rep[List[A]], f : Rep[((A) => Boolean)])(implicit paramA : MaybeParamTag[A]) : Rep[List[A]] = ListFilterExt[A](self, f)
   def listFold[A, B](self : Rep[List[A]], init : Rep[B], f : Rep[((B,A) => B)])(implicit paramA : MaybeParamTag[A], paramB : MaybeParamTag[B]) : Rep[B] = ListFoldExt[A, B](self, init, f)
   def listSize[A](self : Rep[List[A]])(implicit paramA : MaybeParamTag[A]) : Rep[Int] = ListSizeExt[A](self)
   def list$plus[A](self : Rep[List[A]], that : Rep[A])(implicit paramA : MaybeParamTag[A]) : Rep[List[A]] = List$plusExt[A](self, that)
   def listPrint[A](self : Rep[List[A]])(implicit paramA : MaybeParamTag[A]) : Rep[Unit] = ListPrintExt[A](self)
   def list_Field_Data[A](self : Rep[List[A]])(implicit paramA : MaybeParamTag[A]) : Rep[Seq[A]] = List_Field_DataExt[A](self)
   def listApplyObject1[A](data : Rep[A]*)(implicit paramA : MaybeParamTag[A]) : Rep[List[A]] = {
      val dataOutput = __liftSeq(data.toSeq)
      ListApplyObject1Ext[A](dataOutput)
    }
   def listApplyObject2[A]()(implicit paramA : MaybeParamTag[A]) : Rep[List[A]] = ListApplyObject2Ext[A]()
   def listZipObject[A, B](as : Rep[List[A]], bs : Rep[List[B]])(implicit paramA : MaybeParamTag[A], paramB : MaybeParamTag[B]) : Rep[List[Tuple2[A, B]]] = ListZipObjectExt[A, B](as, bs)
  type List[A] = list.shallow.List[A]
}


