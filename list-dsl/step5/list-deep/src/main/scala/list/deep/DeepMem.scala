/* Generated by Purgatory 2014-2016 */

package list.deep

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

import ch.epfl.data.sc.pardis.quasi.anf.{ BaseExt, BaseExtIR }
import ch.epfl.data.sc.pardis.quasi.TypeParameters.MaybeParamTag

trait MemOps extends Base with ClassTagOps {  
  // Type representation
  val MemType = MemIRs.MemType
  implicit val typeMem: TypeRep[Mem] = MemType
  implicit class MemRep(self : Rep[Mem]) {

  }
  object Mem {
     def alloc[T](size : Rep[Int])(implicit typeT : TypeRep[T]) : Rep[Array[T]] = memAllocObject[T](size)(typeT)
     def free[T](obj : Rep[Array[T]])(implicit typeT : TypeRep[T]) : Rep[Unit] = memFreeObject[T](obj)(typeT)
  }
  // constructors
   def __newMem() : Rep[Mem] = memNew()
  // IR defs
  val MemNew = MemIRs.MemNew
  type MemNew = MemIRs.MemNew
  val MemAllocObject = MemIRs.MemAllocObject
  type MemAllocObject[T] = MemIRs.MemAllocObject[T]
  val MemFreeObject = MemIRs.MemFreeObject
  type MemFreeObject[T] = MemIRs.MemFreeObject[T]
  // method definitions
   def memNew() : Rep[Mem] = MemNew()
   def memAllocObject[T](size : Rep[Int])(implicit typeT : TypeRep[T]) : Rep[Array[T]] = MemAllocObject[T](size)
   def memFreeObject[T](obj : Rep[Array[T]])(implicit typeT : TypeRep[T]) : Rep[Unit] = MemFreeObject[T](obj)
  type Mem = list.shallow.Mem
}
object MemIRs extends Base {
  import ClassTagIRs._
  // Type representation
  case object MemType extends TypeRep[Mem] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = MemType
    val name = "Mem"
    val typeArguments = Nil
  }
      implicit val typeMem: TypeRep[Mem] = MemType
  // case classes
  case class MemNew() extends ConstructorDef[Mem](List(), "Mem", List(List())){
    override def curriedConstructor = (x: Any) => copy()
  }

  case class MemAllocObject[T](size : Rep[Int])(implicit val typeT : TypeRep[T]) extends FunctionDef[Array[T]](None, "Mem.alloc", List(List(size)), List(typeT)){
    override def curriedConstructor = (copy[T] _)
  }

  case class MemFreeObject[T](obj : Rep[Array[T]])(implicit val typeT : TypeRep[T]) extends FunctionDef[Unit](None, "Mem.free", List(List(obj))){
    override def curriedConstructor = (copy[T] _)
  }

  type Mem = list.shallow.Mem
}
trait MemImplicits extends MemOps { 
  // Add implicit conversions here!
}
trait MemComponent extends MemOps with MemImplicits {  }

trait MemPartialEvaluation extends MemComponent with BasePartialEvaluation {  
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}


// QUASI GENERATED CODE:

object MemQuasiNodes extends BaseExtIR {
  import MemIRs._
  import ClassTagQuasiNodes._
  // case classes
  case class MemNewExt() extends FunctionDef[MemNew, Mem] {
    override def nodeUnapply(t: MemNew): Option[Product] = (MemNew.unapply(t): Option[Product]) map { r =>
      r }
  }
  case class MemAllocObjectExt[T](size : Rep[Int])(implicit val paramT : MaybeParamTag[T]) extends FunctionDef[MemAllocObject[T], Array[T]] {
    override def nodeUnapply(t: MemAllocObject[T]): Option[Product] = (MemAllocObject.unapply(t): Option[Product]) map { r =>
      paramT.define(t.typeT)
      r }
  }
  case class MemFreeObjectExt[T](obj : Rep[Array[T]])(implicit val paramT : MaybeParamTag[T]) extends FunctionDef[MemFreeObject[T], Unit] {
    override def nodeUnapply(t: MemFreeObject[T]): Option[Product] = (MemFreeObject.unapply(t): Option[Product]) map { r =>
      paramT.define(t.typeT)
      r }
  }
  type Mem = list.shallow.Mem
}

trait MemExtOps extends BaseExt with ClassTagExtOps {
  
  import MemQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import ClassTagQuasiNodes._
  implicit class MemRep(self : Rep[Mem]) {
  }
  object Mem {
     def alloc[T](size : Rep[Int])(implicit paramT : MaybeParamTag[T]) : Rep[Array[T]] = memAllocObject[T](size)(paramT)
     def free[T](obj : Rep[Array[T]])(implicit paramT : MaybeParamTag[T]) : Rep[Unit] = memFreeObject[T](obj)(paramT)
  }
  // constructors
   def __newMem() : Rep[Mem] = memNew()
  
  // method definitions
   def memNew() : Rep[Mem] = MemNewExt()
   def memAllocObject[T](size : Rep[Int])(implicit paramT : MaybeParamTag[T]) : Rep[Array[T]] = MemAllocObjectExt[T](size)
   def memFreeObject[T](obj : Rep[Array[T]])(implicit paramT : MaybeParamTag[T]) : Rep[Unit] = MemFreeObjectExt[T](obj)
  type Mem = list.shallow.Mem
}


